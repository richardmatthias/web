<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Static Type Inference</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">CSE 131</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
		<a href="../calendar.html">Calendar</a>
                <a href="../grades.html">Grades</a>
                <a href="../assignments.html">Assignments</a>
                <a href="../lectures.html">Lectures</a>
                <a href="../resources.html">Resources</a>
            </div>
        </div>

        <div id="content">
            <h1>Static Type Inference</h1>

            <h2 id="type-inference">Type Inference</h2>
<p>Garter, aka <strong>G</strong>uaranteed <strong>T</strong>ype <strong>E</strong>nforced <strong>R</strong>eliability, is an extensnion of FDL with <strong>statically inferred types</strong>.</p>
<p><code>garter</code> starts with <code>fer-de-lance</code> and makes one major addition and a minor deletion, in particular, we</p>
<ul>
<li>add <strong>static types</strong>,</li>
<li>replace unbounded tuples, with <strong>pairs</strong>.</li>
</ul>
<p>That is, we now have a proper type system and the <code>Checker</code> is extended to <strong>infer</strong> types for all sub-expressions.</p>
<p>The code proceeds to <code>compile</code> (i.e. <code>Asm</code> generation) <strong>only if it type checks</strong>.</p>
<p>This lets us eliminate a whole bunch of the <strong>dynamic tests</strong></p>
<ul>
<li><code>assertType TNumber</code></li>
<li><code>assertType TBool</code></li>
<li><code>assertType TTuple</code></li>
<li><code>assertBound</code></li>
</ul>
<p>etc. as code that typechecks is <em>guaranteed</em> to pass the checks at run time.</p>
<h2 id="strategy">Strategy</h2>
<p>Lets start with an informal overview of our strategy for type inference; as usual we will then formalize and implement this strategy.</p>
<p>The core idea is this:</p>
<ol type="1">
<li><strong>Traverse</strong> the <code>Expr</code> …</li>
<li><strong>Generating</strong> fresh variables for unknown types…</li>
<li><strong>Unifying</strong> function input types with their arguments …</li>
<li><strong>Substituting</strong> solutions for variables to infer types.</li>
</ol>
<p>Lets do the above procedure informally for a couple of examples!</p>
<h3 id="example-1-inputs-and-outputs">Example 1: Inputs and Outputs</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> incr <span class="fu">=</span> (lambda(x)<span class="fu">:</span> add1(x)) <span class="kw">in</span></a>
<a class="sourceLine" id="cb1-2" title="2">  incr(<span class="dv">7</span>)  </a></code></pre></div>
<h3 id="example-2-polymorphism">Example 2: Polymorphism</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> <span class="fu">id</span> <span class="fu">=</span> (lambda(x)<span class="fu">:</span> x)</a>
<a class="sourceLine" id="cb2-2" title="2">  , a1 <span class="fu">=</span> <span class="fu">id</span>(<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">  , a2 <span class="fu">=</span> <span class="fu">id</span>(true)</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">in</span></a>
<a class="sourceLine" id="cb2-5" title="5">  true  </a></code></pre></div>
<h3 id="example-3-higher-order-functions">Example 3: Higher-Order Functions</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> f    <span class="fu">=</span> (lambda(it, x)<span class="fu">:</span> it(x) <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">  , incr <span class="fu">=</span> lambda(z)<span class="fu">:</span> add1(z)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">in</span></a>
<a class="sourceLine" id="cb3-4" title="4">  f(incr, <span class="dv">10</span>)</a></code></pre></div>
<h3 id="strategy-recap">Strategy Recap</h3>
<ol type="1">
<li><strong>Traverse</strong> the <code>Expr</code> …</li>
<li><strong>Fresh</strong> variables for unknown types…</li>
<li><strong>Unifying</strong> function input types with their arguments …</li>
<li><strong>Substituting</strong> solutions for variables to infer types …</li>
<li><strong>Generalizing</strong> types into polymorphic functions …</li>
<li><strong>Instantiating</strong> polymorphic type variables at each use-site.</li>
</ol>
<h2 id="plan">Plan</h2>
<ol type="1">
<li><a href="#syntax-of-types"><strong>Types</strong></a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions">Variables &amp; Substitution</a></li>
<li><a href="#unification">Unification</a></li>
<li><a href="#generalize-and-instantiate">Generalize &amp; Instantiate</a></li>
<li><a href="#inference">Inferring Types</a></li>
<li><a href="#extensions">Extensions</a></li>
</ol>
<h2 id="syntax">Syntax</h2>
<p>First, lets see how the syntax of our <code>garter</code> changes to enable static types.</p>
<h3 id="syntax-of-types">Syntax of Types</h3>
<p>A <code>Type</code> is one of:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="fu">=</span> <span class="dt">TInt</span>               <span class="co">-- Int</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="fu">|</span> <span class="dt">TBool</span>              <span class="co">-- Bool</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="fu">|</span> [<span class="dt">Type</span>] <span class="fu">:=&gt;</span> <span class="dt">Type</span>    <span class="co">-- (t1,...,tn) =&gt; t</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="fu">|</span> <span class="dt">TVar</span> <span class="dt">TVar</span>          <span class="co">-- a, b, c</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="fu">|</span> <span class="dt">TPair</span> <span class="dt">Type</span> <span class="dt">Type</span>    <span class="co">-- (t0, t1)</span></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="fu">|</span> <span class="dt">TCtor</span> <span class="dt">Ctor</span> [<span class="dt">Type</span>]  <span class="co">-- e.g. C[t1,...,tn]</span></a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>here <code>Ctor</code> and <code>TVar</code> are just string names:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">newtype</span> <span class="dt">Ctor</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="fu">=</span> <span class="dt">CT</span> <span class="dt">String</span>           <span class="co">-- e.g. &quot;List&quot;, &quot;Tree&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">newtype</span> <span class="dt">TVar</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="fu">=</span> <span class="dt">TV</span> <span class="dt">String</span>           <span class="co">-- e.g. a, b, c</span></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>Finally, a <strong>polymorphic type</strong> is represented as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Poly</span> <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TVar</span>] <span class="dt">Type</span> <span class="co">-- e.g. forall a. (a, a) =&gt; Bool</span></a></code></pre></div>
<h3 id="example-monomorphic-types">Example: Monomorphic Types</h3>
<p>A function that</p>
<ul>
<li>takes two input <code>Int</code></li>
<li>returns an output <code>Int</code></li>
</ul>
<p>Has the <em>monomorphic</em> type <code>(Int, Int) =&gt; Int</code></p>
<p>Which we would represent as a <code>Poly</code> value:</p>
<pre><code>  (Forall [] ([TInt, TInt] :=&gt; TInt))          :: Poly</code></pre>
<p><strong>Note:</strong> If a function is <strong>monomorphic</strong> (i.e. <em>not polymorphic</em>), we can just use the empty list of <code>TVar</code>.</p>
<h3 id="example-polymorphic-types">Example: Polymorphic Types</h3>
<p>Similarly, a function that</p>
<ul>
<li>takes a value of <strong>any</strong> type and</li>
<li>returns a value of <strong>the same</strong> type</li>
</ul>
<p>Has the <em>polymorphic</em> type <code>forall a. (a) =&gt; a</code></p>
<p>Which we would represent as a <code>Poly</code> value:</p>
<pre><code>  Forall [TV &quot;a&quot;] ([TVar (TV &quot;a&quot;)] :=&gt; (TVar (TV &quot;a&quot;)))</code></pre>
<p><strong>Note:</strong> Haskell allows <code>OverloadedStrings</code> which lets us treat <code>&quot;a&quot;</code> as both a <code>TVar</code> and a <code>Type</code> as needed. So we can rewrite the above as:</p>
<pre><code>  Forall [&quot;a&quot;] ([&quot;a&quot;] :=&gt; &quot;a&quot;)</code></pre>
<p>Similarly, a function that takes two values and returns the first, can be given a <code>Poly</code> type <code>forall a, b. (a, b) =&gt; a</code> which is represented as:</p>
<pre><code>  Forall [&quot;a&quot;, &quot;b&quot;] ([&quot;a&quot;, &quot;b&quot;] :=&gt; &quot;a&quot;)</code></pre>
<h3 id="syntax-of-expressions">Syntax of Expressions</h3>
<p>To enable inference <code>garter</code> simplifies the language a little bit.</p>
<ul>
<li><p><em>Dynamic tests</em> <code>isNum</code> and <code>isBool</code> are removed,</p></li>
<li><p><em>Tuples</em> always have exactly <em>two</em> elements; you can represent <code>(x, y, z)</code> as <code>(x, (y, z))</code>.</p></li>
<li><p><em>Tuple</em> access is limited to the fields <code>Zero</code> and <code>One</code> (instead of arbitrary expressions).</p></li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="fu">=</span> <span class="fu">...</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="fu">|</span> <span class="dt">Tuple</span>   (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)                    a <span class="co">-- Tuples have 2 elems</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="fu">|</span> <span class="dt">GetItem</span> (<span class="dt">Expr</span> a) <span class="dt">Field</span>                       a <span class="co">-- Access 0-th or 1-st elem</span></a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="fu">|</span> <span class="dt">Fun</span>     (<span class="dt">Bind</span> a) <span class="dt">Sig</span>     [<span class="dt">Bind</span> a]  (<span class="dt">Expr</span> a)  a <span class="co">-- named functions</span></a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="kw">data</span> <span class="dt">Field</span></a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="fu">=</span> <span class="dt">Zero</span>            <span class="co">-- 0-th field</span></a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="fu">|</span> <span class="dt">One</span>             <span class="co">-- 1-st field                     </span></a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="kw">data</span> <span class="dt">Sig</span></a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="fu">=</span> <span class="dt">Infer</span>           <span class="co">-- no specification, infer scheme  </span></a>
<a class="sourceLine" id="cb11-13" title="13">  <span class="fu">|</span> <span class="dt">Check</span>  <span class="dt">Poly</span>     <span class="co">-- check that function has given (poly-) type</span></a>
<a class="sourceLine" id="cb11-14" title="14">  <span class="fu">|</span> <span class="dt">Assume</span> <span class="dt">Poly</span>     <span class="co">--  </span></a></code></pre></div>
<h3 id="plan-1">Plan</h3>
<ol type="1">
<li><a href="#syntax-of-types">Types</a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions"><strong>Variables &amp; Substitution</strong></a></li>
<li><a href="#unification">Unification</a></li>
<li><a href="#generalize-and-instantiate">Generalize &amp; Instantiate</a></li>
<li><a href="#inference">Inferring Types</a></li>
<li><a href="#extensions">Extensions</a></li>
</ol>
<h2 id="substitutions">Substitutions</h2>
<p>Our informal algorithm proceeds by</p>
<ul>
<li>Generating <strong>fresh type</strong> variables for unknown types,</li>
<li>Traversing the <code>Expr</code> to <strong>unify</strong> the types of sub-expressions,</li>
<li>By <strong>substituting</strong> a type <em>variable</em> with a whole <em>type</em>.</li>
</ul>
<p>Lets formalize <em>substitutions</em>, and use it to define <a href="#unification">unification</a>.</p>
<h3 id="representing-substitutions">Representing Substitutions</h3>
<p>We represent substitutions as a record with two fields:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">Subst</span> <span class="fu">=</span> <span class="dt">Su</span></a>
<a class="sourceLine" id="cb12-2" title="2">  {<span class="ot"> suMap ::</span> <span class="dt">M.Map</span> <span class="dt">TVar</span> <span class="dt">Type</span>    <span class="co">-- ^ hashmap from type-var := type</span></a>
<a class="sourceLine" id="cb12-3" title="3">  ,<span class="ot"> suCnt ::</span> <span class="fu">!</span><span class="dt">Int</span>               <span class="co">-- ^ counter used to generate fresh type vars</span></a>
<a class="sourceLine" id="cb12-4" title="4">  }</a></code></pre></div>
<ul>
<li><code>suMap</code> is a <strong>map</strong> from type variables to types,</li>
<li><code>suCnt</code> is a <strong>counter</strong> used to generate <strong>new</strong> type variables.</li>
</ul>
<p>For example, <code>exSubst</code> is a substitution that maps <code>a</code>, <code>b</code> and <code>c</code> to <code>Int</code>, <code>Bool</code> and <code>(Int, Int) =&gt; Int</code> respectively.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">exSubst ::</span> <span class="dt">Subst</span></a>
<a class="sourceLine" id="cb13-2" title="2">exSubst <span class="fu">=</span> <span class="dt">Su</span> m <span class="dv">0</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-4" title="4">    m   <span class="fu">=</span> (M.fromList [ (<span class="st">&quot;a&quot;</span>, <span class="dt">TInt</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">                      , (<span class="st">&quot;b&quot;</span>, <span class="dt">TBool</span>)</a>
<a class="sourceLine" id="cb13-6" title="6">                      , (<span class="st">&quot;c&quot;</span>, [<span class="dt">TInt</span>, <span class="dt">TInt</span>] <span class="fu">:=&gt;</span> <span class="dt">TInt</span>) ])</a>
<a class="sourceLine" id="cb13-7" title="7"></a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">apply exSubst ([<span class="dt">Int</span>, <span class="st">&quot;zong&quot;</span>] <span class="fu">:=&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb13-10" title="10"></a></code></pre></div>
<h3 id="applying-substitutions">Applying Substitutions</h3>
<p>The main <em>use</em> of a substition is to <strong>apply</strong> it to a type, which has the effect of <em>replacing</em> each occurrence of a type variable with its substituted value (or leaving it untouched if it is not mentioned in the substitution.)</p>
<p>We define an interface for “things that can be substituted” as:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">class</span> <span class="dt">Substitutable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">  apply     ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>and then we define how to <code>apply</code> substitutions to <code>Type</code>, <code>Poly</code>, and lists and maps of <code>Type</code> and <code>Poly</code>.</p>
<p>For example,</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">apply exSubst ([<span class="st">&quot;a&quot;</span>, <span class="st">&quot;z&quot;</span>] <span class="fu">:=&gt;</span> <span class="st">&quot;b&quot;</span>)</a></code></pre></div>
<p>returns</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">[<span class="dt">TInt</span>, <span class="st">&quot;z&quot;</span>] <span class="fu">:=&gt;</span> <span class="dt">TBool</span></a></code></pre></div>
<p>by replacing <code>&quot;a&quot;</code> and <code>&quot;b&quot;</code> with <code>TInt</code> and <code>TBool</code> and leaving “z” alone.</p>
<h3 id="quiz">QUIZ</h3>
<p>Recall that <code>exSubst = [&quot;a&quot; := TInt, &quot;b&quot; := TBool]</code>…</p>
<p>What should be the result of</p>
<pre><code>apply exSubst (Forall &quot;a&quot; ([&quot;a&quot;] :=&gt; &quot;a&quot;))</code></pre>
<ol type="1">
<li><code>Forall [&quot;a&quot;] ([TInt] :=&gt; TBool)</code></li>
<li><code>Forall [&quot;a&quot;] ([&quot;a&quot; ] :=&gt; &quot;a&quot;  )</code></li>
<li><code>Forall [&quot;a&quot;] ([&quot;a&quot;]  :=&gt; TBool)</code></li>
<li><code>Forall [&quot;a&quot;] ([TInt] :=&gt; &quot;a&quot;)</code></li>
<li><code>Forall [   ] ([TInt] :=&gt; TBool)</code></li>
</ol>
<h3 id="bound-vs.free-type-variables">Bound vs. Free Type Variables</h3>
<p>Indeed, the type</p>
<pre><code>forall a. (a) =&gt; a</code></pre>
<p>is identical to</p>
<pre><code>forall z. (z) =&gt; a</code></pre>
<ul>
<li><p>A <strong>bound</strong> type variable is one that appears under a <code>forall</code>.</p></li>
<li><p>A <strong>free</strong> type variable is one that is <strong>not</strong> bound.</p></li>
</ul>
<p>We should only substitute <strong>free type variables</strong>.</p>
<h3 id="applying-substitutions-1">Applying Substitutions</h3>
<p>Thus, keeping the above in mind, we can define <code>apply</code> as a recursive traversal:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">  apply _  <span class="dt">TInt</span>          <span class="fu">=</span> <span class="dt">TInt</span></a>
<a class="sourceLine" id="cb20-2" title="2">  apply _  <span class="dt">TBool</span>         <span class="fu">=</span> <span class="dt">TBool</span></a>
<a class="sourceLine" id="cb20-3" title="3">  apply su (<span class="dt">TVar</span> a)      <span class="fu">=</span> M.findWithDefault (<span class="dt">TVar</span> a) a (suMap su)</a>
<a class="sourceLine" id="cb20-4" title="4">  apply su (ts <span class="fu">:=&gt;</span> t)    <span class="fu">=</span> apply su ts <span class="fu">:=&gt;</span> apply su t</a>
<a class="sourceLine" id="cb20-5" title="5">  apply su (<span class="dt">Forall</span> as t) <span class="fu">=</span> <span class="dt">Forall</span> as <span class="fu">$</span> apply (unSubst as su)  t</a></code></pre></div>
<p>where <code>unSubst</code> <strong>removes</strong> the mappings for <code>as</code> from <code>su</code></p>
<h3 id="creating-substitutions">Creating Substitutions</h3>
<p>We can start with an <strong>empty substitution</strong> that maps no variables</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">empSubst ::</span> <span class="dt">Subst</span></a>
<a class="sourceLine" id="cb21-2" title="2">empSubst <span class="fu">=</span>  <span class="dt">Su</span> M.empty <span class="dv">0</span></a></code></pre></div>
<h3 id="extending-substitutions">Extending Substitutions</h3>
<p>we can <strong>extend</strong> the substitution by assigning a variable <code>a</code> to type <code>t</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">extSubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></a>
<a class="sourceLine" id="cb22-2" title="2">extSubst su a t <span class="fu">=</span> su { suMap <span class="fu">=</span> M.insert a t su' }</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" title="4">     su'        <span class="fu">=</span> apply (mkSubst [(a, t)]) (suMap su)</a></code></pre></div>
<p><strong>Telescoping</strong></p>
<p>Note that when we extend <code>[b := a]</code> by assigning <code>a</code> to <code>Int</code> we must take care to also update <code>b</code> to now map to <code>Int</code>. That is, we want:</p>
<pre><code>    extSubst [ &quot;b&quot; := &quot;a&quot; ] &quot;a&quot; TInt</code></pre>
<p>to be</p>
<pre><code>    [ &quot;b&quot; := TInt, &quot;a&quot; := TInt ]</code></pre>
<p>That is why we:</p>
<ol type="1">
<li><code>apply [a := Int]</code> to update the old substitution to get <code>su'</code></li>
<li><code>insert</code> the new assignment <code>a := Int</code> into <code>su'</code>.</li>
</ol>
<h3 id="plan-2">Plan</h3>
<ol type="1">
<li><a href="#syntax-of-types">Types</a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions">Variables &amp; Substitution</a></li>
<li><a href="#unification"><strong>Unification</strong></a></li>
<li><a href="#generalize-and-instantiate">Generalize &amp; Instantiate</a></li>
<li><a href="#inference">Inferring Types</a></li>
<li><a href="#extensions">Extensions</a></li>
</ol>
<h2 id="unification">Unification</h2>
<p>Next, lets use <code>Subst</code> to implement a procedure to <code>unify</code> two types, i.e. to determine the conditions under which the two types are <em>the same</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>T1</strong></th>
<th style="text-align: left;"><strong>T2</strong></th>
<th style="text-align: left;"><strong>Unified</strong></th>
<th style="text-align: left;"><strong>Substitution</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>empSubst</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a</code></td>
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>a := Int</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>a</code></td>
<td style="text-align: left;"><code>b</code></td>
<td style="text-align: left;"><code>b</code></td>
<td style="text-align: left;"><code>a := b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a -&gt; b</code></td>
<td style="text-align: left;"><code>a -&gt; d</code></td>
<td style="text-align: left;"><code>a-&gt;d</code></td>
<td style="text-align: left;"><code>b := d</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>a -&gt; Int</code></td>
<td style="text-align: left;"><code>Bool -&gt; b</code></td>
<td style="text-align: left;"><code>Bool -&gt; Int</code></td>
<td style="text-align: left;"><code>a := Bool, b:=Int</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>Bool</code></td>
<td style="text-align: left;"><em>Error</em></td>
<td style="text-align: left;"><em>Error</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Int</code></td>
<td style="text-align: left;"><code>a -&gt; b</code></td>
<td style="text-align: left;"><em>Error</em></td>
<td style="text-align: left;"><em>Error</em></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a</code></td>
<td style="text-align: left;"><code>a -&gt; Int</code></td>
<td style="text-align: left;"><em>Error</em></td>
<td style="text-align: left;"><em>Error</em></td>
</tr>
</tbody>
</table>
<ul>
<li>The first few cases: unification is possible,</li>
<li>The last few cases: unification fails, i.e. type error in source!</li>
</ul>
<p><strong>Occurs Check</strong></p>
<ul>
<li><p>The very last failure: <code>a</code> in the first type <strong>occurs inside</strong> free inside the second type!</p></li>
<li><p>If we try substituting <code>a</code> with <code>a -&gt; Int</code> we will just keep spinning forever! Hence, this also throws a unification failure.</p></li>
</ul>
<p><strong>Exercise</strong></p>
<p>Can you think of a program that would trigger the <em>occurs check</em> failure? (You’ve probable written several such programs in 130 and 131!)</p>
<h3 id="implementing-unification">Implementing Unification</h3>
<p>We implement unification as a function:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="ot">unify ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></a></code></pre></div>
<p>such that</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">unify su t1 t2</a></code></pre></div>
<p>returns a substitution <code>su'</code> that <strong>extends</strong> <code>su</code> with with the assignments needed to make <code>t1</code> the same as <code>t2</code>, i.e. such that <code>apply su' t1 == apply su' t2</code>.</p>
<p>The code is pretty much the table above:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="ot">unify ::</span> <span class="dt">SourceSpan</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></a>
<a class="sourceLine" id="cb27-2" title="2">unify _  su <span class="dt">TInt</span>       <span class="dt">TInt</span>         <span class="fu">=</span> su</a>
<a class="sourceLine" id="cb27-3" title="3">unify _  su <span class="dt">TBool</span>      <span class="dt">TBool</span>        <span class="fu">=</span> su</a>
<a class="sourceLine" id="cb27-4" title="4">unify sp su (<span class="dt">TVar</span> a)   t            <span class="fu">=</span> varAsgn sp su a t</a>
<a class="sourceLine" id="cb27-5" title="5">unify sp su t          (<span class="dt">TVar</span> a)     <span class="fu">=</span> varAsgn sp su a t</a>
<a class="sourceLine" id="cb27-6" title="6">unify sp su (is <span class="fu">:=&gt;</span> o) (is' <span class="fu">:=&gt;</span> o') <span class="fu">=</span> unify (unifys sp su is is') (apply s1 o) (apply s1 o')</a>
<a class="sourceLine" id="cb27-7" title="7">unify sp _  t1 t2                   <span class="fu">=</span> abort (errUnify sp t1 t2)</a></code></pre></div>
<p>The helpers</p>
<ul>
<li><code>unifys</code> recursively calls <code>unify</code> on <em>lists</em> of types:</li>
<li><code>varAsgn</code> extends <code>su</code> with <code>[a := t]</code> if <strong>required</strong> and <strong>possible</strong>!</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">varAsgn ::</span> <span class="dt">SourceSpan</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span></a>
<a class="sourceLine" id="cb28-2" title="2">varAsgn sp su a t</a>
<a class="sourceLine" id="cb28-3" title="3">  <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TVar</span> a          <span class="fu">=</span> su                       <span class="co">-- assigned to itself, do nothing</span></a>
<a class="sourceLine" id="cb28-4" title="4">  <span class="fu">|</span> a <span class="ot">`elem`</span> freeTvars t <span class="fu">=</span> abort (errOccurs sp a t) <span class="co">-- oops, fails occurs check!</span></a>
<a class="sourceLine" id="cb28-5" title="5">  <span class="fu">|</span> <span class="fu">otherwise</span>            <span class="fu">=</span> extSubst su a t          <span class="co">-- extend su with [a := t]</span></a></code></pre></div>
<p>We can test out the above table:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3">λ<span class="fu">&gt;</span> unify junkSpan empSubst <span class="dt">TInt</span> <span class="dt">TInt</span></a>
<a class="sourceLine" id="cb29-4" title="4">(fromList [], <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6">λ<span class="fu">&gt;</span> unify junkSpan empSubst ([<span class="st">&quot;a&quot;</span>] <span class="fu">:=&gt;</span> <span class="dt">TInt</span>) ([<span class="dt">TBool</span>] <span class="fu">:=&gt;</span> <span class="st">&quot;b&quot;</span>)</a>
<a class="sourceLine" id="cb29-7" title="7">(fromList [(a,<span class="dt">Bool</span>), (b,<span class="dt">Int</span>)], <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb29-8" title="8"></a>
<a class="sourceLine" id="cb29-9" title="9">λ<span class="fu">&gt;</span> unify junkSpan empSubst (<span class="st">&quot;a&quot;</span>) ([<span class="st">&quot;a&quot;</span>] <span class="fu">:=&gt;</span> <span class="dt">TInt</span>)</a>
<a class="sourceLine" id="cb29-10" title="10"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="st">&quot;Type error: occurs check fails: a occurs in (a) =&gt; Int&quot;</span><span class="fu">...</span></a>
<a class="sourceLine" id="cb29-11" title="11"></a>
<a class="sourceLine" id="cb29-12" title="12">λ<span class="fu">&gt;</span> unify junkSpan empSubst <span class="dt">TInt</span> <span class="dt">TBool</span></a>
<a class="sourceLine" id="cb29-13" title="13"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="st">&quot;Type error: cannot unify Int and Bool&quot;</span> <span class="fu">...</span></a></code></pre></div>
<h3 id="plan-3">Plan</h3>
<ol type="1">
<li><a href="#syntax-of-types">Types</a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions">Variables &amp; Substitution</a></li>
<li><a href="#unification">Unification</a></li>
<li><a href="#generalize-and-instantiate"><strong>Generalize &amp; Instantiate</strong></a></li>
<li><a href="#inference">Inferring Types</a></li>
<li><a href="#extensions">Extensions</a></li>
</ol>
<h2 id="generalize-and-instantiate">Generalize and Instantiate</h2>
<p>Ok, the next step is an easy one. Recall the example:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">let</span> <span class="fu">id</span> <span class="fu">=</span> (lambda(x)<span class="fu">:</span> x)</a>
<a class="sourceLine" id="cb30-2" title="2">  , a1 <span class="fu">=</span> <span class="fu">id</span>(<span class="dv">7</span>)</a>
<a class="sourceLine" id="cb30-3" title="3">  , a2 <span class="fu">=</span> <span class="fu">id</span>(true)</a>
<a class="sourceLine" id="cb30-4" title="4"><span class="kw">in</span></a>
<a class="sourceLine" id="cb30-5" title="5">  true  </a></code></pre></div>
<p>For the expression <code>lambda(x): x</code> we inferred the type <code>(a0) =&gt; a0</code></p>
<p>We needed to <strong>generalize</strong> the above:</p>
<ul>
<li>to assign <code>id</code> the <code>Poly</code>-type: <code>forall a0. (a0) =&gt; a0</code></li>
</ul>
<p>We needed to <strong>instantiate</strong> the above <code>Poly</code>-type at each <em>use</em></p>
<ul>
<li>at <code>id(7)</code> the function <code>id</code> has <code>Type</code> <code>(Int)  =&gt; Int</code></li>
<li>at <code>id(true)</code> the function <code>id</code> has <code>Type</code> <code>(Bool) =&gt; Int</code></li>
</ul>
<p>Lets see how to implement those two steps.</p>
<h3 id="type-environments">Type Environments</h3>
<p>To <code>generalize</code> a type, we</p>
<ol type="1">
<li>Compute its (free) type variables,</li>
<li>Remove the ones that may still be constrained by <em>other</em> in-scope program variables.</li>
</ol>
<p>We represent the types of <strong>in scope</strong> program variables as <strong>type environment</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">data</span> <span class="dt">TypeEnv</span> <span class="fu">=</span> <span class="dt">TypeEnv</span> (<span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Poly</span>)</a></code></pre></div>
<p>i.e. a <code>Map</code> from program variables <code>Id</code> to their (inferred) <code>Poly</code> type.</p>
<h3 id="generalize">Generalize</h3>
<p>We can now implement <code>generalize</code> as:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">generalize ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Poly</span></a>
<a class="sourceLine" id="cb32-2" title="2">generalize env t <span class="fu">=</span> <span class="dt">Forall</span> as t           <span class="co">-- 4. slap a `Forall` on the unconstrained vars</span></a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" title="4">    tvs          <span class="fu">=</span> freeTvars t           <span class="co">-- 1. compute tyVars of `t`</span></a>
<a class="sourceLine" id="cb32-5" title="5">    evs          <span class="fu">=</span> freeTvars env         <span class="co">-- 2. compute tyVars of `env`</span></a>
<a class="sourceLine" id="cb32-6" title="6">    as           <span class="fu">=</span> L.nub (tvs <span class="dt">L</span><span class="fu">.</span>\\ evs)  <span class="co">-- 3. compute unconstrained vars: (1) minus (2)</span></a></code></pre></div>
<p>The helper <code>freeTvars</code> computes the set of variables that appear inside a <code>Type</code>, <code>Poly</code> and <code>TypeEnv</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1">  <span class="co">-- | type-vars of a Type</span></a>
<a class="sourceLine" id="cb33-2" title="2">  freeTvars <span class="dt">TInt</span>          <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb33-3" title="3">  freeTvars <span class="dt">TBool</span>         <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb33-4" title="4">  freeTvars (<span class="dt">TVar</span> a)      <span class="fu">=</span> [a]</a>
<a class="sourceLine" id="cb33-5" title="5">  freeTvars (ts <span class="fu">:=&gt;</span> t)    <span class="fu">=</span> freeTvars ts <span class="fu">++</span> freeTvars t</a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7">  <span class="co">-- | type-vars of a Poly (we remove the &quot;bound&quot; forall-vars)</span></a>
<a class="sourceLine" id="cb33-8" title="8">  freeTvars (<span class="dt">Forall</span> as t) <span class="fu">=</span> freeTvars t <span class="dt">L</span><span class="fu">.</span>\\ as  </a>
<a class="sourceLine" id="cb33-9" title="9"></a>
<a class="sourceLine" id="cb33-10" title="10">  <span class="co">-- | type-vars of an TypeEnv</span></a>
<a class="sourceLine" id="cb33-11" title="11">  freeTvars (<span class="dt">TypeEnv</span> m)   <span class="fu">=</span> freeTvars [s <span class="fu">|</span> (x, s) <span class="ot">&lt;-</span> M.toList m]  </a></code></pre></div>
<h3 id="instantiate">Instantiate</h3>
<p>Next, to <strong>instantiate</strong> a <code>Poly</code> of the form</p>
<pre><code>   Forall [a1,...,an] t</code></pre>
<p>we:</p>
<ol type="1">
<li>Generate <strong>fresh</strong> type variables, <code>b1,...,bn</code> for each “parameter” <code>a1...an</code></li>
<li>Substitute <code>[a1 := b1,...,an := bn]</code> in the “body” <code>t</code>.</li>
</ol>
<p>For example, to instantiate</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1">   <span class="dt">Forall</span> [<span class="st">&quot;a&quot;</span>] ([<span class="st">&quot;a&quot;</span>] <span class="fu">:=&gt;</span> <span class="st">&quot;a&quot;</span>)</a></code></pre></div>
<p>we</p>
<ol type="1">
<li>Generate a fresh variable e.g. <code>&quot;a66&quot;</code>,</li>
<li>Substitute <code>[&quot;a&quot; := &quot;a66&quot;]</code> in the body <code>[&quot;a&quot;] :=&gt; &quot;a&quot;</code></li>
</ol>
<p>to get</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1">[<span class="st">&quot;a66&quot;</span>] <span class="fu">:=&gt;</span> <span class="st">&quot;a66&quot;</span></a></code></pre></div>
<h3 id="implementing-instantiate">Implementing Instantiate</h3>
<p>We implement the above as:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="ot">instantiate ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Poly</span> <span class="ot">-&gt;</span> (<span class="dt">Subst</span>, <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb37-2" title="2">instantiate su (<span class="dt">Forall</span> as t) <span class="fu">=</span> (su', apply suInst t)</a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-4" title="4">    (su', as')               <span class="fu">=</span> freshTVars su n</a>
<a class="sourceLine" id="cb37-5" title="5">    suInst                   <span class="fu">=</span> mkSubst (<span class="fu">zip</span> as as')</a>
<a class="sourceLine" id="cb37-6" title="6">    n                        <span class="fu">=</span> <span class="fu">length</span> as</a></code></pre></div>
<p><strong>Question</strong> Why does <code>instantiate</code> <strong>return</strong> a <code>Subst</code>?</p>
<p>Lets run it and see what happens!</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1">λ<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span></a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3">λ<span class="fu">&gt;</span> <span class="kw">let</span> tId <span class="fu">=</span> <span class="dt">Forall</span> [<span class="st">&quot;a&quot;</span>] ([<span class="st">&quot;a&quot;</span>] <span class="fu">:=&gt;</span> <span class="st">&quot;a&quot;</span>)</a>
<a class="sourceLine" id="cb38-4" title="4"></a>
<a class="sourceLine" id="cb38-5" title="5">λ<span class="fu">&gt;</span> <span class="kw">let</span> (su0, id0) <span class="fu">=</span> instantiate empSubst tId</a>
<a class="sourceLine" id="cb38-6" title="6"></a>
<a class="sourceLine" id="cb38-7" title="7">λ<span class="fu">&gt;</span> <span class="kw">let</span> (su1, id1) <span class="fu">=</span> instantiate su0      tId</a>
<a class="sourceLine" id="cb38-8" title="8"></a>
<a class="sourceLine" id="cb38-9" title="9">λ<span class="fu">&gt;</span> id0</a>
<a class="sourceLine" id="cb38-10" title="10">(a0) <span class="ot">=&gt;</span> a0</a>
<a class="sourceLine" id="cb38-11" title="11"></a>
<a class="sourceLine" id="cb38-12" title="12">λ<span class="fu">&gt;</span> id1</a>
<a class="sourceLine" id="cb38-13" title="13">(a1) <span class="ot">=&gt;</span> a1</a></code></pre></div>
<p>As in <code>anf</code> and <code>label</code></p>
<ul>
<li>The <code>fresh</code> calls <strong>bump up</strong> the counter …</li>
<li>But must use the <strong>returned</strong> <code>Subst</code> for future calls.</li>
</ul>
<h3 id="plan-4">Plan</h3>
<ol type="1">
<li><a href="#syntax-of-types">Types</a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions">Variables &amp; Substitution</a></li>
<li><a href="#unification">Unification</a></li>
<li><a href="#generalize-and-instantiate">Generalize &amp; Instantiate</a></li>
<li><a href="#inference"><strong>Inferring Types</strong></a></li>
<li><a href="#extensions">Extensions</a></li>
</ol>
<h2 id="inference">Inference</h2>
<p>Finally, we have all the pieces to implement the actual <strong>type inference</strong> procedure <code>ti</code></p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="ot">ti ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> (<span class="dt">Subst</span>, <span class="dt">Type</span>)</a></code></pre></div>
<p>The function <code>ti</code> takes as <em>input</em>:</p>
<ol type="1">
<li>A <code>TypeEnv</code> mapping in-scope variables to their inferred (<code>Poly</code>)-types,</li>
<li>A <code>Subst</code> containing the <em>current</em> substitutions and fresh-variable-counter,</li>
<li>An <code>Expr</code> whose type we want to infer.</li>
</ol>
<p>and returns as output a pair of:</p>
<ul>
<li>The inferred type for the given <code>Expr</code> and</li>
<li>The extended <code>Subst</code> resulting from
<ul>
<li>generating fresh type variables and</li>
<li>doing the unification needed to check the <code>Expr</code>.</li>
</ul></li>
</ul>
<p>Lets look at how <code>ti</code> is implemented for the different cases of expressions.</p>
<h3 id="inference-literals">Inference: Literals</h3>
<p>For numbers and booleans, we just return the respective type and the input <code>Subst</code> without any modifications.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1">ti _ su   (<span class="dt">Number</span> {})      <span class="fu">=</span> (su, <span class="dt">TInt</span>)</a>
<a class="sourceLine" id="cb40-2" title="2">ti _ su   (<span class="dt">Boolean</span> {})     <span class="fu">=</span> (su, <span class="dt">TBool</span>)</a></code></pre></div>
<h3 id="inference-variables">Inference: Variables</h3>
<p>For identifiers, we</p>
<ol type="1">
<li><strong>lookup</strong> their type in the <code>env</code> and</li>
<li><strong>instantiate</strong> type-variables to get <em>different types at different uses</em>.</li>
</ol>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1">ti env su (<span class="dt">Id</span> x l) <span class="fu">=</span> instantiate su (lookupTypeEnv x env)</a></code></pre></div>
<p>Why do we <em>instantiate</em>? Recall <a href="generalize-and-instantiate">the <code>id</code> example!</a></p>
<h3 id="inference-let-bindings">Inference: Let-bindings</h3>
<p>Next, lets look at let-bindings:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1">ti env su (<span class="dt">Let</span> x e1 e2 _)  <span class="fu">=</span> ti env'' su1 e2         <span class="co">-- (5)</span></a>
<a class="sourceLine" id="cb42-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-3" title="3">    (su1, t1)              <span class="fu">=</span> ti env su  e1           <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb42-4" title="4">    env'                   <span class="fu">=</span> apply su1  env          <span class="co">-- (2)</span></a>
<a class="sourceLine" id="cb42-5" title="5">    s1                     <span class="fu">=</span> generalize env' t1      <span class="co">-- (3)</span></a>
<a class="sourceLine" id="cb42-6" title="6">    env''                  <span class="fu">=</span> extTypeEnv x s1 env'    <span class="co">-- (4)</span></a></code></pre></div>
<p>In essence,</p>
<ol type="1">
<li><strong>Infer</strong> the type <code>t1</code> for <code>e1</code>,</li>
<li><strong>Apply</strong> the substitutions from (1) to the <code>env</code>,</li>
<li><strong>Generalize</strong> <code>t1</code> to make it a <code>Poly</code> type <code>s1</code>,
<ul>
<li>why? <a href="#generalize-and-instantiate">recall the id example</a></li>
</ul></li>
<li><strong>Extend</strong> the env to map <code>x</code> to <code>s1</code> and,</li>
<li><strong>Infer</strong> the type of <code>e2</code> in the extended environment.</li>
</ol>
<h3 id="inference-function-definitions">Inference: Function Definitions</h3>
<p>Next, lets see how to infer the type of a function i.e. <code>Lam</code></p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1">ti env su (<span class="dt">Lam</span> xs body) <span class="fu">=</span> (su3, apply su3 (tXs <span class="fu">:=&gt;</span> tOut))   <span class="co">-- (5)</span></a>
<a class="sourceLine" id="cb43-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-3" title="3">    (su1, tXs <span class="fu">:=&gt;</span> tOut) <span class="fu">=</span> freshFun su (<span class="fu">length</span> xs)           <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb43-4" title="4">    env'                <span class="fu">=</span> extTypesEnv env (<span class="fu">zip</span> xs tXs)      <span class="co">-- (2)</span></a>
<a class="sourceLine" id="cb43-5" title="5">    (su2, tBody)        <span class="fu">=</span> ti env' su1 body                  <span class="co">-- (3)</span></a>
<a class="sourceLine" id="cb43-6" title="6">    su3                 <span class="fu">=</span> unify su2 tBody (apply su2 tOut)  <span class="co">-- (4)</span></a></code></pre></div>
<p>Inference works as follows:</p>
<ol type="1">
<li>Generate a <em>function type</em> with fresh variables for the unknown inputs (<code>tXs</code>) and output (<code>tOut</code>),</li>
<li>Extend the <code>env</code> so the parameters <code>xs</code> have types <code>tXs</code>,</li>
<li>Infer the type of <code>body</code> under the extended <code>env'</code> as <code>tBody</code>,</li>
<li>Unify the <em>expected</em> output <code>tOut</code> with the <em>actual</em> <code>tBody</code></li>
<li>Apply the substitutions to infer the function’s type <code>tXs :=&gt; tOut</code>.</li>
</ol>
<h3 id="inference-function-calls">Inference: Function Calls</h3>
<p>Finally, lets see how to infer the types of a call i.e. <code>App</code></p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1">ti env su (<span class="dt">App</span> f es) <span class="fu">=</span> (su4, apply su4 tOut)          <span class="co">-- (6)</span></a>
<a class="sourceLine" id="cb44-2" title="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-3" title="3">    (su1, tF)        <span class="fu">=</span> ti env su  f                   <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb44-4" title="4">    env'             <span class="fu">=</span> apply  su1 env                 <span class="co">-- (2)</span></a>
<a class="sourceLine" id="cb44-5" title="5">    (su2, tEs)       <span class="fu">=</span> L.mapAccumL (ti env') su1 es   <span class="co">-- (3)</span></a>
<a class="sourceLine" id="cb44-6" title="6">    (su3, tOut)      <span class="fu">=</span> freshTVar su2                  <span class="co">-- (4)</span></a>
<a class="sourceLine" id="cb44-7" title="7">    su4              <span class="fu">=</span> unify su3 tF (tEs <span class="fu">:=&gt;</span> tOut)    <span class="co">-- (5)</span></a></code></pre></div>
<p>The code works as follows:</p>
<ol type="1">
<li>Infer the type of the function <code>f</code> as <code>tF</code>,</li>
<li>Apply resulting substitutions to <code>env</code> (as before),</li>
<li>Infer the types of the inputs <code>es</code> as <code>tEs</code>,</li>
<li>Generate a variable for the unknown output type,</li>
<li>Unify the <em>actual</em> input-output <code>tEs :=&gt; tOut</code> with the <em>expected</em> <code>tF</code></li>
<li>Return the (substituted) <code>tOut</code> as the inferred type of the expression.</li>
</ol>
<p><strong>Note:</strong> In your starter code we <em>factor</em> out steps 3-6, i.e. the code that checks the arguments and infers the output type into <code>tiApp</code> to let us reuse it to <a href="#extensions">handle extensions</a></p>
<h3 id="plan-5">Plan</h3>
<ol type="1">
<li><a href="#syntax-of-types">Types</a></li>
<li><a href="#syntax-of-expressions">Expressions</a></li>
<li><a href="#substitutions">Variables &amp; Substitution</a></li>
<li><a href="#unification">Unification</a></li>
<li><a href="#generalize-and-instantiate">Generalize &amp; Instantiate</a></li>
<li><a href="#inference">Inferring Types</a></li>
<li><a href="#extensions"><strong>Extensions</strong></a></li>
</ol>
<h2 id="extensions">Extensions</h2>
<p>The above gives you the basic idea, now <em>you</em> will have to implement a bunch of extensions.</p>
<ol type="1">
<li>Primitives</li>
<li>(Recursive) Functions</li>
<li>Type Checking</li>
</ol>
<h3 id="extensions-primitives">Extensions: Primitives</h3>
<p>What about <em>primitives</em> ?</p>
<ul>
<li><code>add1(e)</code>, <code>print(e)</code>, <code>e1 + e2</code> etc.</li>
</ul>
<p>What about <em>branches</em> ?</p>
<ul>
<li><code>if cond: e1 else: e2</code></li>
</ul>
<p>What about <em>tuples</em> ?</p>
<ul>
<li><code>(e1, e2)</code> and <code>e[0]</code> and <code>e[1]</code></li>
</ul>
<p>All of the above can be handled as <strong>applications</strong> to special functions.</p>
<p>For example, you can handle <code>add1(e)</code> by treating it as passing a parameter <code>e</code> to a function with type:</p>
<pre><code>  (Int) =&gt; Int</code></pre>
<p>Similarly, handle <code>e1 + e2</code> by treating it as passing the parameters <code>[e1, e2]</code> to a function with type:</p>
<pre><code>  (Int, Int) =&gt; Int</code></pre>
<p>Can you figure out how to similarly account for branches, tuples, etc. by filling in suitable implementations of:</p>
<ul>
<li><code>prim2Poly</code></li>
<li><code>ifPoly</code></li>
<li><code>tupPoly</code>, <code>fieldPoly</code></li>
</ul>
<p><strong>HINT:</strong> Use the implementation for <code>prim1Poly</code> (and <code>instApp</code>, <code>tiApp</code>) in the starter code as a guide.</p>
<h3 id="extensions-recursive-functions">Extensions: (Recursive) Functions</h3>
<p>Extend or modify the code for handling <code>Lam xs e</code> so that you can handle <code>Fun f xs e</code>. This is mostly straightforward:</p>
<ul>
<li>You can basically reuse the code as is</li>
<li><strong>Except</strong> if <code>f</code> appears in the body of <code>e</code></li>
</ul>
<p>Can you figure out how to modify the environment under which <code>e</code> is checked to handle the above case?</p>
<h3 id="extensions-type-checking">Extensions: Type Checking</h3>
<p>While inference is great, it is often useful to <em>specify</em> the types.</p>
<p>While inference is great, it is often useful to <em>specify</em> the types.</p>
<ul>
<li>They can describe behavior of <em>untyped code</em></li>
<li>They can be nice <em>documentation</em>, e.g. when we want a function to have a more <em>restrictive</em> type.</li>
</ul>
<h3 id="assuming-specifications-for-untyped-code">Assuming Specifications for Untyped Code</h3>
<p>For example, we can <strong>implement</strong> lists as tuples and tell the type system to:</p>
<ul>
<li><strong>trust the implementation</strong> of the core list library API, but</li>
<li><strong>verify the uses</strong> of the list library.</li>
</ul>
<p>We do this by:</p>
<pre><code>def null() as forall a. () =&gt; List[a]:
  false
in

def link(h, t) as forall a. (a, List[a]) =&gt; List[a]:
  (h, t)
in

def tail(l) as forall a. (List[a]) =&gt; List[a]:
  l[1]
in

def length(l):
  if l == null():
    0
  else:
    1 + length(tail(l))
in

let l0 = link(0, link(1, link(2, null())))
in
    length(l0)</code></pre>
<p>The <code>as</code> keyword tells the system to <strong>trust</strong> the signature, i.e. to <strong>assume</strong> it is ok, and to <strong>not check</strong> the implementations of the function (see how <code>ti</code> works for <code>Assume</code>.)</p>
<p>However, the signatures are <strong>used</strong> to ensure that <code>null</code>, <code>link</code> and <code>tail</code> are used properly, for example, if we tried <a href="tests/input/err-list.gtr">the following</a></p>
<pre><code>    link(1, link(true, null()))</code></pre>
<p>we should get an error:</p>
<pre><code>tests/input/err-list.gtr:9:1-24: Type error: cannot unify Int and Bool

         9|  link(1, link(true, null()))
             ^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
<h3 id="checking-specifications">Checking Specifications</h3>
<p>Finally, sometimes we may want to restrict a function be used to some more <em>specific</em> type than what would be inferred.</p>
<p><code>garter</code> allows for specifications on functions using the <code>::</code> operator. For example, you may want a special function that just compares two <code>Int</code> for equality:</p>
<pre><code>def eqInt(x, y) :: (Int, Int) =&gt; Bool :
  x == y
in
  eqInt(17, 19)  </code></pre>
<p>As another example, you might write a <code>swapList</code> function that swaps <strong>pairs of lists</strong> The same code would swap arbitrary pairs, but lets say you really want it work just for lists:</p>
<pre><code>def null() as forall a. () =&gt; List[a]:
  false
in

def link(h, t) as forall a. (a, List[a]) =&gt; List[a]:
  (h, t)
in

def swapList(p) :: forall a.((List[a], List[b])) =&gt; (List[b], List[a]) :
  (p[1], p[0])
in

let l0 = link(1, null())
  , l1 = link(true, null())
in
  swapList((l0, l1))</code></pre>
<p>Can you figure out how to extend the <code>ti</code> procedure to handle the case of <code>Fun f (Check s) xs e</code>, and thus allow for <strong>checking type specifications</strong>?</p>
<p><strong>HINT:</strong> You may want to <em>factor</em> out steps 2-5 in the <code>ti</code> definition for <code>Lam xs body</code> — i.e. the code that checks the <code>body</code> has type <code>tOut</code> when <code>xs</code> have type <code>tXs</code> — into a separate function to implement the <code>ti</code> cases for</p>
<ul>
<li><code>Fun f (Infer) xs e</code></li>
<li><code>Fun f (Check) xs e</code></li>
</ul>
<p>This is a bit tricky, and so am leaving it as <strong>Extra Extra Credit</strong>.</p>
        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
